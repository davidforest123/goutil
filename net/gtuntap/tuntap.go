package gtuntap

import (
	"fmt"
	"io"
	"net"
	"runtime"
	"strings"

	"github.com/davidforest123/goutil/basic/gerrors"
	"github.com/davidforest123/goutil/net/gnet"
	"github.com/davidforest123/goutil/sys/gcmd"
	"github.com/davidforest123/goutil/sys/gio"
	"github.com/songgao/water"
)

type (
	Iface struct {
		deviceType  string
		name        string
		mtu         int
		deviceIPNet net.IPNet
		destIP      net.IP
		ifce        *water.Interface
	}

	OpenRWC = func() (io.ReadWriteCloser, error)
)

// New creates new TUN/TAP device.
// On macOS, Name is not customizable.
func New(deviceType string, name string, mtu int, deviceIPNet net.IPNet) *Iface {
	return &Iface{
		deviceType:  deviceType,
		name:        name,
		mtu:         mtu,
		deviceIPNet: deviceIPNet,
		destIP:      deviceIPNet.IP,
	}
	// destIP: default route target IP address of current TUN/TAP device.
	// destIP是虚拟网卡的默认目的地址，当一个IP报文的目标地址是该IP时，这个报文就会被路由到该虚拟网卡，
	// 而一个虚拟网卡只用于路由唯一一个目的IP的情况几乎没有，所以通常，我们把deviceIP和destIP设置为同一个IP，
	// 这就相当于不需要这个destIP设置发挥实际作用，我们采取后续补充设置多个路由的方式，那样更灵活。
}

// SudoSetup starts a TUN/TAP device.
//
// Notice：
// 1、如果程序退出，即使是强行结束进程，TUN设备、ifconfig所自动创建的临时路由、通过route命令创建的TUN设备相关的临时路由，都会被系统自动清除。macOS下亲测如此
func (i *Iface) SudoSetup() error {
	switch runtime.GOOS {
	case "darwin":
		if strings.ToLower(i.deviceType) != "tun" {
			return gerrors.New("macOS doesn't support deviceType %s", i.deviceType)
		}

		config := water.Config{
			DeviceType: water.TUN,
		}
		err := error(nil)
		if i.ifce, err = water.New(config); err != nil {
			return err
		}
		setConfigName(&config, i.Name()) // on macOS, TUN name is NOT customizable, it is given automatically by the system.

		// config IP, netmask, mtu... for created TUN interface.
		// This operation will not only set the network information of the TUN, but also silently and automatically
		// create a `Host` type temporary routing rule with the `deviceIP` as the route gateway and the `destIP` as the
		// route destination address, and all data sent to the `destIP` will pass through the TUN device.
		// 这个操作除了会设置TUN的网络信息，还会悄悄自动创建一条Host类型的临时的路由规则，以deviceIP为路由网关，
		// 以DestIP为路由目的地址，所有发送到destIP的数据都会从TUN设备通过。
		cmd := fmt.Sprintf("/sbin/ifconfig %s netmask %s mtu %d %s %s up", i.Name(), gnet.WrapIPMask(i.deviceIPNet.Mask).DecString(), i.mtu, i.deviceIPNet.IP.String(), i.destIP.String())
		if out, err := gcmd.RunScript(cmd); err != nil {
			return fmt.Errorf("err: %s %s", err, string(out))
		}
		return nil

	case "linux":
		config := water.Config{
			DeviceType: water.TUN,
		}
		if i.name == "" {
			return gerrors.New("under linux tun device name can't be null")
		}
		setConfigName(&config, i.Name())
		err := error(nil)
		if i.ifce, err = water.New(config); err != nil {
			return err
		}

		// config IP, netmask, mtu... for created TUN interface
		var cmds []string
		if gcmd.CommandExists("ip") {
			//cmds = append(cmds, fmt.Sprintf("sudo ip addr add %s dev %s; sudo ip link set mtu %d dev %s up", gnet.WrapIPNet(i.DeviceIPNet()).String(), i.Name(), i.mtu, i.Name()))
			cmds = append(cmds, fmt.Sprintf("sudo ip addr add %s dev %s", gnet.WrapIPNet(i.DeviceIPNet()).String(), i.Name()))
			cmds = append(cmds, fmt.Sprintf("sudo ip link set mtu %d dev %s up", i.mtu, i.Name()))
		} else if gcmd.CommandExists("ifconfig") {
			cmds = append(cmds, fmt.Sprintf("ifconfig %s %s netmask %s mtu %d", i.Name(), i.DeviceIPNet().IP.String(), gnet.WrapIPMask(i.deviceIPNet.Mask).DecString(), i.mtu))
		} else {
			return gerrors.New("neither `ip` nor `ifconfig` command found")
		}
		if out, err := gcmd.RunScripts(cmds...); err != nil {
			return fmt.Errorf("SudoSetup RunScripts: %s %s", err, string(out))
		}
		return nil

	case "windows":
		config := water.Config{
			DeviceType: water.TUN,
		}
		err := error(nil)
		setConfigName(&config, i.Name())
		if i.ifce, err = water.New(config); err != nil {
			return err
		}
		return nil

	default:
		return gerrors.New("SudoStart function does not support %s", runtime.GOOS)
	}
}

// Name returns device name.
// On macOS, it is generated by system, but not from `name` param of `New(...)` function.
func (i *Iface) Name() string {
	return i.ifce.Name()
}

func (i *Iface) DeviceIPNet() net.IPNet {
	return i.deviceIPNet
}

func (i *Iface) DestIP() net.IP {
	return i.destIP
}

// SudoAddNetRoute add `net` type route, all traffic sent to destNet will be forward to current TUN/TAP device.
func (i *Iface) SudoAddNetRoute(destNet net.IPNet) error {
	return gnet.SudoAddNetRoute(i.Name(), destNet, destNet.IP.String())
}

func (i *Iface) DeleteNetRoute(destNet net.IPNet) error {
	return gnet.DeleteNetRoute(i.Name(), destNet, destNet.IP.String())
}

// ServeByConn starts VPN after accept `.vpn` stream.
func (i *Iface) ServeByConn(conn io.ReadWriteCloser) error {
	if conn == nil {
		return gerrors.New("invalid net.Conn")
	}

	errResult := error(nil)
	errNotify := func(err error) {
		errResult = gerrors.Wrap(err, "TwoWaysCopy: ")
	}
	gio.TwoWaysCopy(conn, i, errNotify)
	conn.Close() // don't forget to close it

	return errResult
}

// ServeByDeviceData starts VPN after device accepted IP packet.
// 只有从虚拟网卡中读到数据，才去建立`.vpn` stream，并进行交换
func (i *Iface) ServeByDeviceData(openRWC OpenRWC) (bool, error) {
	if openRWC == nil {
		return false, gerrors.New("invalid openRWC")
	}

	errResult := error(nil)
	errNotify := func(err error) {
		errResult = err
	}

	// 为什么不直接使用TwoWayCopy呢，因为gmux.Stream的读写有noDataTimeout超时机制，超过一定时间没有数据进出这个Stream就会失效
	// 所以，我们在收到数据的时候才打开VPN stream
	rBuf := make([]byte, 4096)
	rTotal := 0
	err := error(nil)
	for {
		rTotal, err = i.Read(rBuf)
		if err != nil {
			return false, err
		}
		if rTotal > 0 {
			break
		}
	}

	conn, err := openRWC()
	if err != nil {
		return false, err
	}
	wTotal := 0
	for wTotal < rTotal {
		n, err := conn.Write(rBuf[wTotal:])
		if err != nil {
			return true, err
		}
		wTotal += n
	}

	gio.TwoWaysCopy(conn, i, errNotify)
	conn.Close() // don't forget to close it

	return true, errResult
}

func (i *Iface) Read(pkt []byte) (int, error) {
	return i.ifce.Read(pkt)
}

func (i *Iface) Write(pkt []byte) (int, error) {
	return i.ifce.Write(pkt)
}

func (i *Iface) Close() error {
	return i.ifce.Close()
}

type PacketIP []byte

func NewPacketIP(size int) PacketIP {
	return PacketIP(make([]byte, size))
}

func (p PacketIP) GetSourceIP() net.IP {
	return net.IP(p[12:16])
}

func (p PacketIP) GetDestinationIP() net.IP {
	return net.IP(p[16:20])
}
